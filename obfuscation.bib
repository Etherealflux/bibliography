Automatically generated by Mendeley Desktop 1.19.5
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Options -> BibTeX in Mendeley Desktop

@article{Xu2017a,
abstract = {Program obfuscation is a widely employed approach for software intellectual property protection. However, general obfuscation methods (e.g., lexical obfuscation, control obfuscation) implemented in mainstream obfuscation tools are heuristic and have little security guarantee. Recently in 2013, Garg et al. have achieved a breakthrough in secure program obfuscation with a graded encoding mechanism and they have shown that it can fulfill a compelling security property, i.e., indistinguishability. Nevertheless, the mechanism incurs too much overhead for practical usage. Besides, it focuses on obfuscating computation models (e.g., circuits) rather than real codes. In this paper, we aim to explore secure and usable obfuscation approaches from the literature. Our main finding is that currently we still have no such approaches made secure and usable. The main reason is we do not have adequate evaluation metrics concerning both security and performance. On one hand, existing code-oriented obfuscation approaches generally evaluate the increased obscurity rather than security guarantee. On the other hand, the performance requirement for model-oriented obfuscation approaches is too weak to develop practical program obfuscation solutions.},
archivePrefix = {arXiv},
arxivId = {1710.01139},
author = {Xu, Hui and Zhou, Yangfan and Kang, Yu and Lyu, Michael R.},
eprint = {1710.01139},
file = {:home/hausss/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Xu et al. - 2017 - On Secure and Usable Program Obfuscation A Survey.pdf:pdf},
month = {oct},
title = {{On Secure and Usable Program Obfuscation: A Survey}},
url = {http://arxiv.org/abs/1710.01139},
year = {2017}
}
@inproceedings{collberg98,
abstract = {It has become common to distribute software in forms that are isomorphic to the original source code. An important example is Java bytecode. Since such codes are easy to decompile, they increase the risk of malicious reverse engineering attacks. In this paper we describe the design of a Java code obfuscator, a tool which - through the application of code transformations - converts a Java program into an equivalent one that is more difficult to reverse engineer. We describe a number of transformations which obfuscate control-flow. Transformations are evaluated with respect to potency (To what degree is a human reader confused?), resilience (How well are automatic deobfuscation attacks resisted?), cost (How much time/space overhead is added?), and stealth (How well does obfuscated code blend in with the original code?). The resilience of many control-altering transformations rely on the resilience of opaque predicates. These are boolean valued expressions whose values are known to the obfuscator but difficult to determine for an automatic deobfuscator. We show how to construct resilient, cheap, and stealthy opaque predicates based on the intractability of certain static analysis problems such as alias analysis.},
address = {New York, NY, USA},
author = {Collberg, Christian and Thomborson, Clark and Low, Douglas},
booktitle = {Conference Record of the Annual ACM Symposium on Principles of Programming Languages},
doi = {10.1145/268946.268962},
isbn = {0897919793},
issn = {07308566},
pages = {184--196},
publisher = {Association for Computing Machinery},
series = {POPL '98},
title = {{Manufacturing cheap, resilient, and stealthy opaque constructs}},
url = {https://doi.org/10.1145/268946.268962},
year = {1998}
}
@techreport{Collberg1997,
abstract = {It has become more and more common to distribute software in forms that retain most or all of the information present in the original source code. An important example is Java bytecode. Since such codes are easy to decompile, they increase the risk of malicious reverse engineering attacks. par In this paper we review several techniques for technical protection of software secrets. We will argue that automatic em code obfuscation is currently the most viable method for preventing reverse engineering. We then describe the design of a em code obfuscator, a tool which converts a program into an equivalent one that is more difficult to understand and reverse engineer. par The obfuscator is based on the application of code transformations, in many cases similar to those used by compiler optimizers. We describe a large number of such transformations, classify them, and evaluate them with respect to their em potency (To what degree is a human reader confused?), em resilience (How well are automatic em deobfuscation attacks resisted?), and em cost (How much overhead is added to the application?). par We finally discuss some possible deobfuscation techniques (such as program em slicing) and possible counter-measures an obfuscator could employ against them.},
author = {Collberg, C and Thomborson, C and Low, D},
doi = {10.1.1.38.9852},
institution = {The University of Auckland},
isbn = {1173-3500},
issn = {11733500},
number = {148},
pages = {36},
title = {{A taxonomy of obfuscating transformations}},
url = {http://scholar.google.com/scholar?hl=en{\&}btnG=Search{\&}q=intitle:A+Taxonomy+of+Obfuscating+Transformations{\#}0},
year = {1997}
}
