Automatically generated by Mendeley Desktop 1.19.5
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Options -> BibTeX in Mendeley Desktop

@article{Roundy2013,
abstract = {The first steps in analyzing defensive malware are understanding what obfuscations are present in realworld malware binaries, how these obfuscations hinder analysis, and how they can be overcome. While some obfuscations have been reported independently, this survey consolidates the discussion while adding substantial depth and breadth to it. This survey also quantifies the relative prevalence of these obfuscations by using the Dyninst binary analysis and instrumentation tool that was recently extended for defensive malware analysis. The goal of this survey is to encourage analysts to focus on resolving the obfuscations that are most prevalent in real-world malware. {\textcopyright} 2013 ACM.},
author = {Roundy, Kevin A. and Miller, Barton P.},
doi = {10.1145/2522968.2522972},
file = {:home/hausss/Documents/Mendeley Desktop/Roundy, Miller - 2013 - Binary-code obfuscations in prevalent packer tools.pdf:pdf},
issn = {03600300},
journal = {ACM Computing Surveys},
keywords = {Malware,Obfuscation,Program binary analysis},
number = {1},
pages = {1--24},
title = {{Binary-code obfuscations in prevalent packer tools}},
volume = {46},
year = {2013}
}
@techreport{Collberg1997,
abstract = {It has become more and more common to distribute software in forms that retain most or all of the information present in the original source code. An important example is Java bytecode. Since such codes are easy to decompile, they increase the risk of malicious reverse engineering attacks. par In this paper we review several techniques for technical protection of software secrets. We will argue that automatic em code obfuscation is currently the most viable method for preventing reverse engineering. We then describe the design of a em code obfuscator, a tool which converts a program into an equivalent one that is more difficult to understand and reverse engineer. par The obfuscator is based on the application of code transformations, in many cases similar to those used by compiler optimizers. We describe a large number of such transformations, classify them, and evaluate them with respect to their em potency (To what degree is a human reader confused?), em resilience (How well are automatic em deobfuscation attacks resisted?), and em cost (How much overhead is added to the application?). par We finally discuss some possible deobfuscation techniques (such as program em slicing) and possible counter-measures an obfuscator could employ against them.},
author = {Collberg, C and Thomborson, C and Low, D},
doi = {10.1.1.38.9852},
file = {:home/hausss/Documents/Mendeley Desktop/Collberg, Thomborson, Low - 1997 - A taxonomy of obfuscating transformations.pdf:pdf;::},
institution = {The University of Auckland},
isbn = {1173-3500},
issn = {11733500},
number = {148},
pages = {36},
title = {{A taxonomy of obfuscating transformations}},
url = {http://scholar.google.com/scholar?hl=en{\&}btnG=Search{\&}q=intitle:A+Taxonomy+of+Obfuscating+Transformations{\#}0},
year = {1997}
}
@article{Barak2012,
abstract = {Informally, an obfuscator O is an (efficient, probabilistic) "compiler" that takes as input a program (or circuit) P and produces a new program O(P) that has the same functionality as P yet is "unintelligible" in some sense. Obfuscators, if they exist, would have a wide variety of cryptographic and complexity-theoretic applications, ranging from software protection to homomorphic encryption to complexity-theoretic analogues of Rice's theorem.Most of these applications are based on an interpretation of the "unintelligibility" condition in obfuscation as meaning that O(P) is a "virtual black box," in the sense that anything one can efficiently compute given O(P), one could also efficiently compute given oracle access to P. In this work, we initiate a theoretical investigation of obfuscation. Our main result is that, even under very weak formalizations of the above intuition, obfuscation is impossible. We prove this by constructing a family of efficient programs P that are unobfuscatable in the sense that (a) given any efficient program P that computes the same function as a program P $\epsilon$ P, the "source code" P can be efficiently reconstructed, yet (b) given oracle access to a (randomly selected) program P $\epsilon$ P, no efficient algorithm can reconstruct P (or even distinguish a certain bit in the code from random) except with negligible probability. We extend our impossibility result in a number of ways, including even obfuscators that (a) are not necessarily computable in polynomial time, (b) only approximately preserve the functionality, and (c) only need to work for very restricted models of computation (TC0).We also rule out several potential applications of obfuscators, by constructing "unobfuscatable" signature schemes, encryption schemes, and pseudorandom function families. {\textcopyright} 2012 ACM.},
author = {Barak, Boaz and Goldreich, Oded and Impagliazzo, Russell and Rudich, Steven and Ucla, Amit Sahai and Vadhan, Salil and Yang, Ke},
doi = {10.1145/2160158.2160159},
file = {:home/hausss/Documents/Mendeley Desktop/Barak et al. - 2012 - On the (Im)possibility of obfuscating programs.pdf:pdf},
issn = {00045411},
journal = {Journal of the ACM},
keywords = {Complexity theory,Cryptography,Homomorphic encryption,Pseudorandom functions,Rice's Theorem,Software protection,Software watermarking,Statistical zero knowledge},
month = {apr},
number = {2},
title = {{On the (Im)possibility of obfuscating programs}},
volume = {59},
year = {2012}
}
@article{Xu2017a,
abstract = {Program obfuscation is a widely employed approach for software intellectual property protection. However, general obfuscation methods (e.g., lexical obfuscation, control obfuscation) implemented in mainstream obfuscation tools are heuristic and have little security guarantee. Recently in 2013, Garg et al. have achieved a breakthrough in secure program obfuscation with a graded encoding mechanism and they have shown that it can fulfill a compelling security property, i.e., indistinguishability. Nevertheless, the mechanism incurs too much overhead for practical usage. Besides, it focuses on obfuscating computation models (e.g., circuits) rather than real codes. In this paper, we aim to explore secure and usable obfuscation approaches from the literature. Our main finding is that currently we still have no such approaches made secure and usable. The main reason is we do not have adequate evaluation metrics concerning both security and performance. On one hand, existing code-oriented obfuscation approaches generally evaluate the increased obscurity rather than security guarantee. On the other hand, the performance requirement for model-oriented obfuscation approaches is too weak to develop practical program obfuscation solutions.},
archivePrefix = {arXiv},
arxivId = {1710.01139},
author = {Xu, Hui and Zhou, Yangfan and Kang, Yu and Lyu, Michael R.},
eprint = {1710.01139},
file = {:home/hausss/Documents/Mendeley Desktop//Xu et al. - 2017 - On Secure and Usable Program Obfuscation A Survey.pdf:pdf},
month = {oct},
title = {{On Secure and Usable Program Obfuscation: A Survey}},
url = {http://arxiv.org/abs/1710.01139},
year = {2017}
}
@inproceedings{collberg98,
abstract = {It has become common to distribute software in forms that are isomorphic to the original source code. An important example is Java bytecode. Since such codes are easy to decompile, they increase the risk of malicious reverse engineering attacks. In this paper we describe the design of a Java code obfuscator, a tool which - through the application of code transformations - converts a Java program into an equivalent one that is more difficult to reverse engineer. We describe a number of transformations which obfuscate control-flow. Transformations are evaluated with respect to potency (To what degree is a human reader confused?), resilience (How well are automatic deobfuscation attacks resisted?), cost (How much time/space overhead is added?), and stealth (How well does obfuscated code blend in with the original code?). The resilience of many control-altering transformations rely on the resilience of opaque predicates. These are boolean valued expressions whose values are known to the obfuscator but difficult to determine for an automatic deobfuscator. We show how to construct resilient, cheap, and stealthy opaque predicates based on the intractability of certain static analysis problems such as alias analysis.},
address = {New York, NY, USA},
author = {Collberg, Christian and Thomborson, Clark and Low, Douglas},
booktitle = {Conference Record of the Annual ACM Symposium on Principles of Programming Languages},
doi = {10.1145/268946.268962},
file = {:home/hausss/Documents/Mendeley Desktop/Collberg, Thomborson, Low - 1998 - Manufacturing cheap, resilient, and stealthy opaque constructs.pdf:pdf},
isbn = {0897919793},
issn = {07308566},
pages = {184--196},
publisher = {Association for Computing Machinery},
series = {POPL '98},
title = {{Manufacturing cheap, resilient, and stealthy opaque constructs}},
url = {https://doi.org/10.1145/268946.268962},
year = {1998}
}
@article{Garg2016,
abstract = {In this work, we study indistinguishability obfuscation and functional encryption for general circuits: Indistinguishability obfuscation requires that given any two equivalent circuits C0 and C1 of similar size, the obfuscations of C0 and C1 should be computationally indistinguishable. In functional encryption, ciphertexts encrypt inputs x and keys are issued for circuits C. Using the key SKC to decrypt a ciphertext CTx=Enc(x) yields the value C(x) but does not reveal anything else about x. Furthermore, no collusion of secret key holders should be able to learn anything more than the union of what they can each learn individually. We give constructions for indistinguishability obfuscation and functional encryption that supports all polynomial-size circuits. We accomplish this goal in three steps: (1) We describe a candidate construction for indistinguishability obfuscation for NC1 circuits. The security of this construction is based on a new algebraic hardness assumption. The candidate and assumption use a simplified variant of multilinear maps, which we call multilinear jigsaw puzzles. (2) We show how to use indistinguishability obfuscation for NC1 together with fully homomorphic encryption (with decryption in NC1) to achieve indistinguishability obfuscation for all circuits. (3) Finally, we show how to use indistinguishability obfuscation for circuits, public-key encryption, and noninteractive zero knowledge to achieve functional encryption for all circuits. The functional encryption scheme we construct also enjoys succinct ciphertexts, which enables several other applications.},
author = {Garg, Sanjam and Gentry, Craig and Halevi, Shai and Raykova, Mariana and Sahai, Amit and Waters, Brent},
doi = {10.1137/14095772X},
file = {:home/hausss/Documents/Mendeley Desktop/Garg et al. - 2016 - Candidate indistinguishability obfuscation and functional encryption for all circuits.pdf:pdf},
issn = {00975397},
journal = {SIAM Journal on Computing},
keywords = {Functional encryption,Obfuscation,Predicate encryption},
number = {3},
pages = {882--929},
publisher = {Society for Industrial and Applied Mathematics Publications},
title = {{Candidate indistinguishability obfuscation and functional encryption for all circuits}},
volume = {45},
year = {2016}
}
