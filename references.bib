% Encoding: UTF-8

@InProceedings{10.1007/978-3-030-17659-4_22,
  author    = {Bartusek, James and Lepoint, Tancr{\`e}de and Ma, Fermi and Zhandry, Mark},
  booktitle = {Advances in Cryptology -- EUROCRYPT 2019},
  title     = {New Techniques for Obfuscating Conjunctions},
  editor    = {Ishai, Yuval and Rijmen, Vincent},
  isbn      = {978-3-030-17659-4},
  pages     = {636--666},
  publisher = {Springer International Publishing},
  abstract  = {A conjunction is a function {\$}{\$}f(x{\_}1,{\backslash}dots ,x{\_}n) = {\backslash}bigwedge {\_}{\{}i {\backslash}in S{\}} l{\_}i{\$}{\$}where {\$}{\$}S {\backslash}subseteq [n]{\$}{\$}and each {\$}{\$}l{\_}i{\$}{\$}is {\$}{\$}x{\_}i{\$}{\$}or {\$}{\$}{\backslash}lnot x{\_}i{\$}{\$}. Bishop et al. (CRYPTO 2018) recently proposed obfuscating conjunctions by embedding them in the error positions of a noisy Reed-Solomon codeword and placing the codeword in a group exponent. They prove distributional virtual black box (VBB) security in the generic group model for random conjunctions where {\$}{\$}|S| {\backslash}ge 0.226n{\$}{\$}. While conjunction obfuscation is known from LWE [31, 47], these constructions rely on substantial technical machinery.},
  address   = {Cham},
  file      = {:10.1007_978-3-030-17659-4_22 - New Techniques for Obfuscating Conjunctions.PDF:PDF},
  groups    = {creation},
  year      = {2019},
}

@InProceedings{10.1007/978-3-540-85174-5_32,
  author    = {Ishai, Yuval and Prabhakaran, Manoj and Sahai, Amit},
  booktitle = {Advances in Cryptology -- CRYPTO 2008},
  title     = {Founding Cryptography on Oblivious Transfer -- Efficiently},
  editor    = {Wagner, David},
  isbn      = {978-3-540-85174-5},
  pages     = {572--591},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {We present a simple and efficient compiler for transforming secure multi-party computation (MPC) protocols that enjoy security only with an honest majority into MPC protocols that guarantee security with no honest majority, in the oblivious-transfer (OT) hybrid model. Our technique works by combining a secure protocol in the honest majority setting with a protocol achieving only security against semi-honest parties in the setting of no honest majority.},
  address   = {Berlin, Heidelberg},
  file      = {:10.1007_978-3-540-85174-5_32 - Founding Cryptography on Oblivious Transfer Efficiently.PDF:PDF},
  groups    = {creation},
  year      = {2008},
}

@InProceedings{10.1145/3359789.3359812,
  author    = {Ollivier, Mathilde and Bardin, S\'{e}bastien and Bonichon, Richard and Marion, Jean-Yves},
  booktitle = {Proceedings of the 35th Annual Computer Security Applications Conference},
  title     = {How to Kill Symbolic Deobfuscation for Free (or: Unleashing the Potential of Path-Oriented Protections)},
  doi       = {10.1145/3359789.3359812},
  isbn      = {9781450376280},
  location  = {San Juan, Puerto Rico},
  pages     = {177–189},
  publisher = {Association for Computing Machinery},
  series    = {ACSAC ’19},
  url       = {https://doi.org/10.1145/3359789.3359812},
  address   = {New York, NY, USA},
  file      = {:Ollivier2019 - How to Kill Symbolic Deobfuscation for Free (or_ Unleashing the Potential of Path Oriented Protections).PDF:PDF},
  groups    = {attacking},
  keywords  = {reverse engineering, obfuscation, code protection},
  numpages  = {13},
  year      = {2019},
}

@InProceedings{5675808,
  author    = {I. {Firdausi} and C. {lim} and A. {Erwin} and A. S. {Nugroho}},
  booktitle = {2010 Second International Conference on Advances in Computing, Control, and Telecommunication Technologies},
  title     = {Analysis of Machine learning Techniques Used in Behavior-Based Malware Detection},
  doi       = {10.1109/ACT.2010.33},
  pages     = {201-203},
  file      = {:5675808 - Analysis of Machine Learning Techniques Used in Behavior Based Malware Detection.pdf:PDF},
  groups    = {detection},
  year      = {2010},
}

@InProceedings{6016774,
  author    = {T. {Wang} and C. {Wu}},
  booktitle = {2011 International Conference on Machine Learning and Cybernetics},
  title     = {Detection of packed executables using support vector machines},
  doi       = {10.1109/ICMLC.2011.6016774},
  pages     = {717-722},
  volume    = {2},
  file      = {:6016774 - Detection of Packed Executables Using Support Vector Machines.pdf:PDF},
  groups    = {detection},
  year      = {2011},
}

@InProceedings{ananth2014optimizing,
  author    = {Ananth, Prabhanjan and Gupta, Divya and Ishai, Yuval and Sahai, Amit},
  booktitle = {Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security},
  title     = {Optimizing obfuscation: avoiding Barrington's theorem},
  pages     = {646--658},
  file      = {:ananth2014optimizing - Optimizing Obfuscation_ Avoiding Barrington's Theorem.PDF:PDF},
  groups    = {creation},
  year      = {2014},
}

@Article{Banescu2016,
  author   = {Banescu, Sebastian and Collberg, Christian and Ganesh, Vijay and Newsham, Zack and Pretschner, Alexander},
  title    = {{Code obfuscation against symbolic execution attacks}},
  doi      = {10.1145/2991079.2991114},
  pages    = {189--200},
  volume   = {5-9-Decemb},
  abstract = {Code obfuscation is widely used by software developers to protect intellectual property, and malware writers to hamper program analysis. However, there seems to be little work on systematic evaluations of effectiveness of obfuscation techniques against automated program analysis. The result is that we have no methodical way of knowing what kinds of automated analyses an obfuscation method can withstand. This paper addresses the problem of characterizing the resilience of code obfuscation transformations against automated symbolic execution attacks, complementing existing works that measure the potency of obfuscation transformations against human-assisted attacks through user studies. We evaluated our approach over 5000 different C programs, which have each been obfuscated using existing implementations of obfuscation transformations. The results show that many existing obfuscation transformations, such as virtualization, stand little chance of withstanding symbolicexecution based deobfuscation. A crucial and perhaps surprising observation we make is that symbolic-execution based deobfuscators can easily deobfuscate transformations that preserve program semantics. On the other hand, we present new obfuscation transformations that change program behavior in subtle yet acceptable ways, and show that they can render symbolic-execution based deobfuscation analysis ineffective in practice.},
  file     = {:Banescu2016 - Code Obfuscation against Symbolic Execution Attacks.pdf:PDF},
  groups   = {creation},
  journal  = {ACM International Conference Proceeding Series},
  year     = {2016},
}

@InProceedings{Barak2001,
  author   = {Boaz Barak and Oded Goldreich and Rusell Impagliazzo and Steven Rudich and Amit Sahai and Salil Vadhan and Ke Yang},
  title    = {On the (Im)possibility of Obfuscating Programs (Extended Abstract)},
  abstract = {Informally, an obfuscator O is an (efficient, probabilistic)
“compiler” that takes as input a program (or circuit) P and produces a
new program O(P ) that has the same functionality as P yet is “unintel-
ligible” in some sense. Obfuscators, if they exist, would have a wide vari-
ety of cryptographic and complexity-theoretic applications, ranging from
software protection to homomorphic encryption to complexity-theoretic
analogues of Rice’s theorem. Most of these applications are based on an
interpretation of the “unintelligibility” condition in obfuscation as mean-
ing that O(P ) is a “virtual black box,” in the sense that anything one
can efficiently compute given O(P ), one could also efficiently compute
given oracle access to P .
In this work, we initiate a theoretical investigation of obfuscation. Our
main result is that, even under very weak formalizations of the above in-
tuition, obfuscation is impossible. We prove this by constructing a family
of functions F that are inherently unobfuscatable in the following sense:
there is a property π : F → {0, 1} such that (a) given any program that
computes a function f ∈ F , the value π(f) can be efficiently computed,
yet (b) given oracle access to a (randomly selected) function f ∈ F , no
efficient algorithm can compute π(f) much better than random guessing.
We extend our impossibility result in a number of ways, including even
obfuscators that (a) are not necessarily computable in polynomial time,
(b) only approximately preserve the functionality, and (c) only need to
work for very restricted models of computation (TC0). We also rule
out several potential applications of obfuscators, by constructing “unob-
fuscatable” signature schemes, encryption schemes, and pseudorandom
function families.},
  file     = {:Barak2001 - On the (Im)possibility of Obfuscating Programs (Extended Abstract).pdf:PDF},
  groups   = {creation},
  year     = {2001},
}

@InProceedings{barak2001possibility,
  author       = {Barak, Boaz and Goldreich, Oded and Impagliazzo, Rusell and Rudich, Steven and Sahai, Amit and Vadhan, Salil and Yang, Ke},
  booktitle    = {Annual International Cryptology Conference},
  title        = {On the (im) possibility of obfuscating programs},
  organization = {Springer},
  pages        = {1--18},
  file         = {:barak2001possibility - On the (im) Possibility of Obfuscating Programs.PDF:PDF},
  groups       = {creation},
  year         = {2001},
}

@Article{Barak2012,
  author   = {Barak, Boaz and Goldreich, Oded and Impagliazzo, Russell and Rudich, Steven and Ucla, Amit Sahai and Vadhan, Salil and Yang, Ke},
  date     = {2012-04-12},
  title    = {{On the (Im)possibility of obfuscating programs}},
  doi      = {10.1145/2160158.2160159},
  issn     = {00045411},
  number   = {2},
  volume   = {59},
  abstract = {Informally, an obfuscator O is an (efficient, probabilistic) "compiler" that takes as input a program (or circuit) P and produces a new program O(P) that has the same functionality as P yet is "unintelligible" in some sense. Obfuscators, if they exist, would have a wide variety of cryptographic and complexity-theoretic applications, ranging from software protection to homomorphic encryption to complexity-theoretic analogues of Rice's theorem.Most of these applications are based on an interpretation of the "unintelligibility" condition in obfuscation as meaning that O(P) is a "virtual black box," in the sense that anything one can efficiently compute given O(P), one could also efficiently compute given oracle access to P. In this work, we initiate a theoretical investigation of obfuscation. Our main result is that, even under very weak formalizations of the above intuition, obfuscation is impossible. We prove this by constructing a family of efficient programs P that are unobfuscatable in the sense that (a) given any efficient program P that computes the same function as a program P $\epsilon$ P, the "source code" P can be efficiently reconstructed, yet (b) given oracle access to a (randomly selected) program P $\epsilon$ P, no efficient algorithm can reconstruct P (or even distinguish a certain bit in the code from random) except with negligible probability. We extend our impossibility result in a number of ways, including even obfuscators that (a) are not necessarily computable in polynomial time, (b) only approximately preserve the functionality, and (c) only need to work for very restricted models of computation (TC0).We also rule out several potential applications of obfuscators, by constructing "unobfuscatable" signature schemes, encryption schemes, and pseudorandom function families. {\textcopyright} 2012 ACM.},
  file     = {:Barak2012 - On the (Im)possibility of Obfuscating Programs.PDF:PDF},
  groups   = {creation},
  journal  = {Journal of the ACM},
  keywords = {Complexity theory, Cryptography, Homomorphic encryption, Pseudorandom functions, Rice's Theorem, Software protection, Software watermarking, Statistical zero knowledge},
}

@Article{Bardin2017,
  author   = {Bardin, Sebastien and David, Robin and Marion, Jean Yves},
  title    = {{Backward-Bounded DSE: Targeting Infeasibility Questions on Obfuscated Codes}},
  doi      = {10.1109/SP.2017.36},
  issn     = {10816011},
  pages    = {633--651},
  abstract = {Software deobfuscation is a crucial activity in security analysis and especially in malware analysis. While standard static and dynamic approaches suffer from well-known shortcomings, Dynamic Symbolic Execution (DSE) has recently been proposed as an interesting alternative, more robust than staticanalysis and more complete than dynamic analysis. Yet, DSE addresses only certain kinds of questions encountered by a reverser, namely feasibility questions. Many issues arising during reverse, e.g., detecting protection schemes such as opaque predicates, fall into the category of infeasibility questions. We present Backward-Bounded DSE, a generic, precise, efficient and robust method for solving infeasibility questions. We demonstrate the benefit of the method for opaque predicates and call stack tampering, and give some insight for its usage for some other protection schemes. Especially, the technique has successfully been used on state-of-the-art packers as well as on the government-grade X-Tunnel malware - allowing its entire deobfuscation. Backward-Bounded DSE does not supersede existing DSE approaches, but rather complements them by addressing infeasibility questions in a scalable and precise manner. Following this line, we proposesparse disassembly, a combination of Backward-Bounded DSE and static disassembly able to enlarge dynamic disassembly in a guaranteed way, hence getting the best of dynamic and static disassembly. This work paves the way for robust, efficient and precise disassembly tools for heavily-obfuscated binaries.},
  file     = {:Bardin2017 - Backward Bounded DSE_ Targeting Infeasibility Questions on Obfuscated Codes.PDF:PDF},
  groups   = {attacking},
  isbn     = {9781509055326},
  journal  = {Proceedings - IEEE Symposium on Security and Privacy},
  keywords = {Code analysis,Deobfuscation,Malware,Reverse-Engineering,Symbolic Execution},
  year     = {2017},
}

@Article{BARRINGTON1989150,
  author   = {David A. Barrington},
  title    = {Bounded-width polynomial-size branching programs recognize exactly those languages in NC1},
  doi      = {https://doi.org/10.1016/0022-0000(89)90037-8},
  issn     = {0022-0000},
  number   = {1},
  pages    = {150 - 164},
  url      = {http://www.sciencedirect.com/science/article/pii/0022000089900378},
  volume   = {38},
  abstract = {We show that any language recognized by an NC1 circuit (fan-in 2, depth O(log n)) can be recognized by a width-5 polynomial-size branching program. As any bounded-width polynomial-size branching program can be simulated by an NC1 circuit, we have that the class of languages recognized by such programs is exactly nonuniform NC1. Further, following Ruzzo (J. Comput. System Sci. 22 (1981), 365–383) and Cook (Inform. and Control 64 (1985) 2–22), if the branching programs are restricted to be ATIME(logn)-uniform, they recognize the same languages as do ATIME(log n)-uniform NC1 circuits, that is, those languages in ATIME(log n). We also extend the method of proof to investigate the complexity of the word problem for a fixed permutation group and show that polynomial size circuits of width 4 also recognize exactly nonuniform NC1.},
  file     = {:BARRINGTON1989150 - Bounded Width Polynomial Size Branching Programs Recognize Exactly Those Languages in NC1.pdf:PDF},
  groups   = {creation},
  journal  = {Journal of Computer and System Sciences},
  year     = {1989},
}

@InProceedings{cheon2015cryptanalysis,
  author       = {Cheon, Jung Hee and Han, Kyoohyung and Lee, Changmin and Ryu, Hansol and Stehl{\'e}, Damien},
  booktitle    = {Annual International Conference on the Theory and Applications of Cryptographic Techniques},
  title        = {Cryptanalysis of the multilinear map over the integers},
  organization = {Springer},
  pages        = {3--12},
  file         = {:cheon2015cryptanalysis - Cryptanalysis of the Multilinear Map Over the Integers.PDF:PDF},
  groups       = {attacking},
  year         = {2015},
}

@Article{Cohen1993,
  author     = {Cohen, Frederick B.},
  title      = {Operating System Protection through Program Evolution},
  doi        = {10.1016/0167-4048(93)90054-9},
  issn       = {0167-4048},
  number     = {6},
  pages      = {565–584},
  url        = {https://doi.org/10.1016/0167-4048(93)90054-9},
  volume     = {12},
  address    = {GBR},
  file       = {:Cohen1993 - Operating System Protection through Program Evolution.pdf:PDF},
  groups     = {creation},
  issue_date = {Oct. 1993},
  journal    = {Comput. Secur.},
  keywords   = {Operating systems, Trusted systems, Program evolution, Computational complexity},
  month      = oct,
  numpages   = {20},
  publisher  = {Elsevier Advanced Technology Publications},
  year       = {1993},
}

@TechReport{Collberg1997,
  author      = {Collberg, C and Thomborson, C and Low, D},
  institution = {The University of Auckland},
  title       = {{A Taxonomy of Obfuscating Transformations}},
  doi         = {10.1.1.38.9852},
  number      = {148},
  pages       = {36},
  url         = {https://www.researchgate.net/profile/Clark{\_}Thomborson/publication/37987523{\_}A{\_}Taxonomy{\_}of{\_}Obfuscating{\_}Transformations/links/00b7d51e34cb9590db000000/A-Taxonomy-of-Obfuscating-Transformations.pdf},
  abstract    = {It has become more and more common to distribute software in forms that retain most or all of the information present in the original source code. An important example is Java bytecode. Since such codes are easy to decompile, they increase the risk of malicious reverse engineering attacks. par In this paper we review several techniques for technical protection of software secrets. We will argue that automatic em code obfuscation is currently the most viable method for preventing reverse engineering. We then describe the design of a em code obfuscator, a tool which converts a program into an equivalent one that is more difficult to understand and reverse engineer. par The obfuscator is based on the application of code transformations, in many cases similar to those used by compiler optimizers. We describe a large number of such transformations, classify them, and evaluate them with respect to their em potency (To what degree is a human reader confused?), em resilience (How well are automatic em deobfuscation attacks resisted?), and em cost (How much overhead is added to the application?). par We finally discuss some possible deobfuscation techniques (such as program em slicing) and possible counter-measures an obfuscator could employ against them.},
  file        = {:Collberg1997 - A Taxonomy of Obfuscating Transformations.pdf:PDF},
  groups      = {creation},
  year        = {1997},
}

@InProceedings{Collberg1998,
  author    = {Collberg, Christian and Thomborson, Clark and Low, Douglas},
  booktitle = {Conference Record of the Annual ACM Symposium on Principles of Programming Languages},
  title     = {{Manufacturing cheap, resilient, and stealthy opaque constructs}},
  doi       = {10.1145/268946.268962},
  isbn      = {0897919793},
  pages     = {184--196},
  publisher = {Association for Computing Machinery},
  series    = {POPL '98},
  url       = {https://doi.org/10.1145/268946.268962},
  abstract  = {It has become common to distribute software in forms that are isomorphic to the original source code. An important example is Java bytecode. Since such codes are easy to decompile, they increase the risk of malicious reverse engineering attacks. In this paper we describe the design of a Java code obfuscator, a tool which - through the application of code transformations - converts a Java program into an equivalent one that is more difficult to reverse engineer. We describe a number of transformations which obfuscate control-flow. Transformations are evaluated with respect to potency (To what degree is a human reader confused?), resilience (How well are automatic deobfuscation attacks resisted?), cost (How much time/space overhead is added?), and stealth (How well does obfuscated code blend in with the original code?). The resilience of many control-altering transformations rely on the resilience of opaque predicates. These are boolean valued expressions whose values are known to the obfuscator but difficult to determine for an automatic deobfuscator. We show how to construct resilient, cheap, and stealthy opaque predicates based on the intractability of certain static analysis problems such as alias analysis.},
  address   = {New York, NY, USA},
  file      = {:Collberg1998 - Manufacturing Cheap, Resilient, and Stealthy Opaque Constructs.PDF:PDF},
  groups    = {creation},
  issn      = {07308566},
  year      = {1998},
}

@Article{Garg2016,
  author   = {Garg, Sanjam and Gentry, Craig and Halevi, Shai and Raykova, Mariana and Sahai, Amit and Waters, Brent},
  title    = {{Candidate indistinguishability obfuscation and functional encryption for all circuits}},
  doi      = {10.1137/14095772X},
  issn     = {00975397},
  number   = {3},
  pages    = {882--929},
  volume   = {45},
  abstract = {In this work, we study indistinguishability obfuscation and functional encryption for general circuits: Indistinguishability obfuscation requires that given any two equivalent circuits C0 and C1 of similar size, the obfuscations of C0 and C1 should be computationally indistinguishable. In functional encryption, ciphertexts encrypt inputs x and keys are issued for circuits C. Using the key SKC to decrypt a ciphertext CTx=Enc(x) yields the value C(x) but does not reveal anything else about x. Furthermore, no collusion of secret key holders should be able to learn anything more than the union of what they can each learn individually. We give constructions for indistinguishability obfuscation and functional encryption that supports all polynomial-size circuits. We accomplish this goal in three steps: (1) We describe a candidate construction for indistinguishability obfuscation for NC1 circuits. The security of this construction is based on a new algebraic hardness assumption. The candidate and assumption use a simplified variant of multilinear maps, which we call multilinear jigsaw puzzles. (2) We show how to use indistinguishability obfuscation for NC1 together with fully homomorphic encryption (with decryption in NC1) to achieve indistinguishability obfuscation for all circuits. (3) Finally, we show how to use indistinguishability obfuscation for circuits, public-key encryption, and noninteractive zero knowledge to achieve functional encryption for all circuits. The functional encryption scheme we construct also enjoys succinct ciphertexts, which enables several other applications.},
  file     = {:Garg2016 - Candidate Indistinguishability Obfuscation and Functional Encryption for All Circuits.PDF:PDF},
  groups   = {creation},
  journal  = {SIAM Journal on Computing},
  keywords = {Functional encryption,Obfuscation,Predicate encryption},
  year     = {2016},
}

@Software{GithubUPX,
  author  = {Oberhumer, Markus and Molnar, Laszlo and Reiser, John},
  date    = {2000-05-19},
  title   = {UPX - the Ultimate Packer for eXecutables},
  type    = {software},
  url     = {https://github.com/upx/upx},
  urldate = {2020-05-11},
  groups  = {creation},
}

@InProceedings{Gosler1986,
  author    = {Gosler, James R},
  booktitle = {Advances in Cryptology --- CRYPTO '85 Proceedings},
  title     = {{Software Protection: Myth or Reality?}},
  editor    = {Williams, Hugh C},
  isbn      = {978-3-540-39799-1},
  pages     = {140--157},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Staggering amounts of commercial software are marketed to fulfill needs from the PC explosion. Unfortunately, such software is trivial to duplicate! From the vendors' viewpoint a way to protect profit is needed. Typically, they have resorted to various schemes that attempt to inhibit the duplication process.},
  address   = {Berlin, Heidelberg},
  groups    = {creation},
  year      = {1986},
}

@InProceedings{Liu2017,
  author    = {Han Liu and Chengnian Sun and Zhendong Su and Yu Jiang and Ming Gu and Jiaguang Sun},
  booktitle = {2017 {IEEE}/{ACM} 39th International Conference on Software Engineering ({ICSE})},
  title     = {Stochastic Optimization of Program Obfuscation},
  doi       = {10.1109/icse.2017.28},
  publisher = {{IEEE}},
  file      = {:Liu2017 - Stochastic Optimization of Program Obfuscation.pdf:PDF},
  groups    = {creation},
  month     = {may},
  year      = {2017},
}

@Article{Roundy2013,
  author     = {Roundy, Kevin A. and Miller, Barton P.},
  title      = {Binary-Code Obfuscations in Prevalent Packer Tools},
  doi        = {10.1145/2522968.2522972},
  issn       = {0360-0300},
  number     = {1},
  url        = {https://doi.org/10.1145/2522968.2522972},
  volume     = {46},
  address    = {New York, NY, USA},
  articleno  = {4},
  file       = {:Roundy2013 - Binary Code Obfuscations in Prevalent Packer Tools.PDF:PDF},
  groups     = {creation},
  issue_date = {October 2013},
  journal    = {ACM Comput. Surv.},
  keywords   = {obfuscation, program binary analysis, Malware},
  month      = jul,
  numpages   = {32},
  publisher  = {Association for Computing Machinery},
  year       = {2013},
}

@Article{Salwan2018,
  author   = {Salwan, Jonathan and Bardin, S{\'{e}}bastien and Potet, Marie Laure},
  title    = {{Symbolic deobfuscation: From virtualized code back to the original}},
  doi      = {10.1007/978-3-319-93411-2_17},
  issn     = {16113349},
  pages    = {372--392},
  volume   = {10885 LNCS},
  abstract = {Software protection has taken an important place during the last decade in order to protect legit software against reverse engineering or tampering. Virtualization is considered as one of the very best defenses against such attacks. We present a generic approach based on symbolic path exploration, taint and recompilation allowing to recover, from a virtualized code, a devirtualized code semantically identical to the original one and close in size. We define criteria and metrics to evaluate the relevance of the deobfuscated results in terms of correctness and precision. Finally we propose an open-source setup allowing to evaluate the proposed approach against several forms of virtualization.},
  file     = {:Salwan2018 - Symbolic Deobfuscation_ from Virtualized Code Back to the Original.PDF:PDF},
  groups   = {attacking},
  journal  = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year     = {2018},
}

@Article{Schrittwieser2016,
  author     = {Schrittwieser, Sebastian and Katzenbeisser, Stefan and Kinder, Johannes and Merzdovnik, Georg and Weippl, Edgar},
  title      = {Protecting Software through Obfuscation: Can It Keep Pace with Progress in Code Analysis?},
  doi        = {10.1145/2886012},
  issn       = {0360-0300},
  number     = {1},
  url        = {https://doi.org/10.1145/2886012},
  volume     = {49},
  address    = {New York, NY, USA},
  articleno  = {4},
  file       = {:Schrittwieser2016 - Protecting Software through Obfuscation_ Can It Keep Pace with Progress in Code Analysis_.PDF:PDF},
  groups     = {creation},
  issue_date = {July 2016},
  journal    = {ACM Comput. Surv.},
  keywords   = {malware, Software obfuscation, program analysis, reverse engineering, software protection},
  month      = apr,
  numpages   = {37},
  publisher  = {Association for Computing Machinery},
  year       = {2016},
}

@Article{Xu2017,
  author        = {Xu, Hui and Zhou, Yangfan and Kang, Yu and Lyu, Michael R.},
  date          = {2017-10-03},
  title         = {{On Secure and Usable Program Obfuscation: A Survey}},
  eprint        = {1710.01139},
  url           = {http://arxiv.org/abs/1710.01139},
  abstract      = {Program obfuscation is a widely employed approach for software intellectual property protection. However, general obfuscation methods (e.g., lexical obfuscation, control obfuscation) implemented in mainstream obfuscation tools are heuristic and have little security guarantee. Recently in 2013, Garg et al. have achieved a breakthrough in secure program obfuscation with a graded encoding mechanism and they have shown that it can fulfill a compelling security property, i.e., indistinguishability. Nevertheless, the mechanism incurs too much overhead for practical usage. Besides, it focuses on obfuscating computation models (e.g., circuits) rather than real codes. In this paper, we aim to explore secure and usable obfuscation approaches from the literature. Our main finding is that currently we still have no such approaches made secure and usable. The main reason is we do not have adequate evaluation metrics concerning both security and performance. On one hand, existing code-oriented obfuscation approaches generally evaluate the increased obscurity rather than security guarantee. On the other hand, the performance requirement for model-oriented obfuscation approaches is too weak to develop practical program obfuscation solutions.},
  archiveprefix = {arXiv},
  arxivid       = {1710.01139},
  file          = {:Xu2017 - On Secure and Usable Program Obfuscation_ a Survey.PDF:PDF},
  groups        = {creation},
  journal       = {CoRR},
}

@Comment{jabref-meta: databaseType:biblatex;}

@Comment{jabref-meta: fileDirectory:./pdfs/;}

@Comment{jabref-meta: fileDirectoryLatex-hausss-DESKTOP-A9EGHSS:C:\\Users\\hausss\\Documents\\RPI\\research;}

@Comment{jabref-meta: grouping:
0 AllEntriesGroup:;
1 StaticGroup:obfuscation\;2\;1\;0x8a8a8aff\;\;\;;
2 StaticGroup:attacking\;0\;1\;0x8a8a8aff\;\;\;;
2 StaticGroup:creation\;0\;1\;0x8a8a8aff\;\;\;;
2 StaticGroup:detection\;0\;0\;0x8a8a8aff\;\;\;;
}

@Comment{jabref-meta: saveOrderConfig:specified;bibtexkey;false;author;false;title;true;}
