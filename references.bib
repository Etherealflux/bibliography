% Encoding: UTF-8

@Article{Banescu2016,
  author   = {Banescu, Sebastian and Collberg, Christian and Ganesh, Vijay and Newsham, Zack and Pretschner, Alexander},
  title    = {{Code obfuscation against symbolic execution attacks}},
  doi      = {10.1145/2991079.2991114},
  pages    = {189--200},
  volume   = {5-9-Decemb},
  abstract = {Code obfuscation is widely used by software developers to protect intellectual property, and malware writers to hamper program analysis. However, there seems to be little work on systematic evaluations of effectiveness of obfuscation techniques against automated program analysis. The result is that we have no methodical way of knowing what kinds of automated analyses an obfuscation method can withstand. This paper addresses the problem of characterizing the resilience of code obfuscation transformations against automated symbolic execution attacks, complementing existing works that measure the potency of obfuscation transformations against human-assisted attacks through user studies. We evaluated our approach over 5000 different C programs, which have each been obfuscated using existing implementations of obfuscation transformations. The results show that many existing obfuscation transformations, such as virtualization, stand little chance of withstanding symbolicexecution based deobfuscation. A crucial and perhaps surprising observation we make is that symbolic-execution based deobfuscators can easily deobfuscate transformations that preserve program semantics. On the other hand, we present new obfuscation transformations that change program behavior in subtle yet acceptable ways, and show that they can render symbolic-execution based deobfuscation analysis ineffective in practice.},
  file     = {:Banescu2016 - Code Obfuscation against Symbolic Execution Attacks.pdf:PDF},
  groups   = {obfuscation},
  journal  = {ACM International Conference Proceeding Series},
  year     = {2016},
}

@Article{Barak2012,
  author   = {Barak, Boaz and Goldreich, Oded and Impagliazzo, Russell and Rudich, Steven and Ucla, Amit Sahai and Vadhan, Salil and Yang, Ke},
  date     = {2012-04-12},
  title    = {{On the (Im)possibility of obfuscating programs}},
  doi      = {10.1145/2160158.2160159},
  issn     = {00045411},
  number   = {2},
  volume   = {59},
  abstract = {Informally, an obfuscator O is an (efficient, probabilistic) "compiler" that takes as input a program (or circuit) P and produces a new program O(P) that has the same functionality as P yet is "unintelligible" in some sense. Obfuscators, if they exist, would have a wide variety of cryptographic and complexity-theoretic applications, ranging from software protection to homomorphic encryption to complexity-theoretic analogues of Rice's theorem.Most of these applications are based on an interpretation of the "unintelligibility" condition in obfuscation as meaning that O(P) is a "virtual black box," in the sense that anything one can efficiently compute given O(P), one could also efficiently compute given oracle access to P. In this work, we initiate a theoretical investigation of obfuscation. Our main result is that, even under very weak formalizations of the above intuition, obfuscation is impossible. We prove this by constructing a family of efficient programs P that are unobfuscatable in the sense that (a) given any efficient program P that computes the same function as a program P $\epsilon$ P, the "source code" P can be efficiently reconstructed, yet (b) given oracle access to a (randomly selected) program P $\epsilon$ P, no efficient algorithm can reconstruct P (or even distinguish a certain bit in the code from random) except with negligible probability. We extend our impossibility result in a number of ways, including even obfuscators that (a) are not necessarily computable in polynomial time, (b) only approximately preserve the functionality, and (c) only need to work for very restricted models of computation (TC0).We also rule out several potential applications of obfuscators, by constructing "unobfuscatable" signature schemes, encryption schemes, and pseudorandom function families. {\textcopyright} 2012 ACM.},
  file     = {:Barak2012 - On the (Im)possibility of Obfuscating Programs.PDF:PDF},
  groups   = {obfuscation},
  journal  = {Journal of the ACM},
  keywords = {Complexity theory,Cryptography,Homomorphic encryption,Pseudorandom functions,Rice's Theorem,Software protection,Software watermarking,Statistical zero knowledge},
}

@Article{Bardin2017,
  author   = {Bardin, Sebastien and David, Robin and Marion, Jean Yves},
  title    = {{Backward-Bounded DSE: Targeting Infeasibility Questions on Obfuscated Codes}},
  doi      = {10.1109/SP.2017.36},
  issn     = {10816011},
  pages    = {633--651},
  abstract = {Software deobfuscation is a crucial activity in security analysis and especially in malware analysis. While standard static and dynamic approaches suffer from well-known shortcomings, Dynamic Symbolic Execution (DSE) has recently been proposed as an interesting alternative, more robust than staticanalysis and more complete than dynamic analysis. Yet, DSE addresses only certain kinds of questions encountered by a reverser, namely feasibility questions. Many issues arising during reverse, e.g., detecting protection schemes such as opaque predicates, fall into the category of infeasibility questions. We present Backward-Bounded DSE, a generic, precise, efficient and robust method for solving infeasibility questions. We demonstrate the benefit of the method for opaque predicates and call stack tampering, and give some insight for its usage for some other protection schemes. Especially, the technique has successfully been used on state-of-the-art packers as well as on the government-grade X-Tunnel malware - allowing its entire deobfuscation. Backward-Bounded DSE does not supersede existing DSE approaches, but rather complements them by addressing infeasibility questions in a scalable and precise manner. Following this line, we proposesparse disassembly, a combination of Backward-Bounded DSE and static disassembly able to enlarge dynamic disassembly in a guaranteed way, hence getting the best of dynamic and static disassembly. This work paves the way for robust, efficient and precise disassembly tools for heavily-obfuscated binaries.},
  file     = {:Bardin2017 - Backward Bounded DSE_ Targeting Infeasibility Questions on Obfuscated Codes.PDF:PDF},
  groups   = {obfuscation},
  isbn     = {9781509055326},
  journal  = {Proceedings - IEEE Symposium on Security and Privacy},
  keywords = {Code analysis,Deobfuscation,Malware,Reverse-Engineering,Symbolic Execution},
  year     = {2017},
}

@TechReport{Collberg1997,
  author      = {Collberg, C and Thomborson, C and Low, D},
  institution = {The University of Auckland},
  title       = {{A Taxonomy of Obfuscating Transformations}},
  doi         = {10.1.1.38.9852},
  number      = {148},
  pages       = {36},
  url         = {https://www.researchgate.net/profile/Clark{\_}Thomborson/publication/37987523{\_}A{\_}Taxonomy{\_}of{\_}Obfuscating{\_}Transformations/links/00b7d51e34cb9590db000000/A-Taxonomy-of-Obfuscating-Transformations.pdf},
  abstract    = {It has become more and more common to distribute software in forms that retain most or all of the information present in the original source code. An important example is Java bytecode. Since such codes are easy to decompile, they increase the risk of malicious reverse engineering attacks. par In this paper we review several techniques for technical protection of software secrets. We will argue that automatic em code obfuscation is currently the most viable method for preventing reverse engineering. We then describe the design of a em code obfuscator, a tool which converts a program into an equivalent one that is more difficult to understand and reverse engineer. par The obfuscator is based on the application of code transformations, in many cases similar to those used by compiler optimizers. We describe a large number of such transformations, classify them, and evaluate them with respect to their em potency (To what degree is a human reader confused?), em resilience (How well are automatic em deobfuscation attacks resisted?), and em cost (How much overhead is added to the application?). par We finally discuss some possible deobfuscation techniques (such as program em slicing) and possible counter-measures an obfuscator could employ against them.},
  file        = {:Collberg1997 - A Taxonomy of Obfuscating Transformations.pdf:PDF},
  groups      = {obfuscation},
  year        = {1997},
}

@InProceedings{Collberg1998,
  author    = {Collberg, Christian and Thomborson, Clark and Low, Douglas},
  booktitle = {Conference Record of the Annual ACM Symposium on Principles of Programming Languages},
  title     = {{Manufacturing cheap, resilient, and stealthy opaque constructs}},
  doi       = {10.1145/268946.268962},
  isbn      = {0897919793},
  pages     = {184--196},
  publisher = {Association for Computing Machinery},
  series    = {POPL '98},
  url       = {https://doi.org/10.1145/268946.268962},
  abstract  = {It has become common to distribute software in forms that are isomorphic to the original source code. An important example is Java bytecode. Since such codes are easy to decompile, they increase the risk of malicious reverse engineering attacks. In this paper we describe the design of a Java code obfuscator, a tool which - through the application of code transformations - converts a Java program into an equivalent one that is more difficult to reverse engineer. We describe a number of transformations which obfuscate control-flow. Transformations are evaluated with respect to potency (To what degree is a human reader confused?), resilience (How well are automatic deobfuscation attacks resisted?), cost (How much time/space overhead is added?), and stealth (How well does obfuscated code blend in with the original code?). The resilience of many control-altering transformations rely on the resilience of opaque predicates. These are boolean valued expressions whose values are known to the obfuscator but difficult to determine for an automatic deobfuscator. We show how to construct resilient, cheap, and stealthy opaque predicates based on the intractability of certain static analysis problems such as alias analysis.},
  address   = {New York, NY, USA},
  file      = {:Collberg1998 - Manufacturing Cheap, Resilient, and Stealthy Opaque Constructs.PDF:PDF},
  groups    = {obfuscation},
  issn      = {07308566},
  year      = {1998},
}

@Article{Garg2016,
  author   = {Garg, Sanjam and Gentry, Craig and Halevi, Shai and Raykova, Mariana and Sahai, Amit and Waters, Brent},
  title    = {{Candidate indistinguishability obfuscation and functional encryption for all circuits}},
  doi      = {10.1137/14095772X},
  issn     = {00975397},
  number   = {3},
  pages    = {882--929},
  volume   = {45},
  abstract = {In this work, we study indistinguishability obfuscation and functional encryption for general circuits: Indistinguishability obfuscation requires that given any two equivalent circuits C0 and C1 of similar size, the obfuscations of C0 and C1 should be computationally indistinguishable. In functional encryption, ciphertexts encrypt inputs x and keys are issued for circuits C. Using the key SKC to decrypt a ciphertext CTx=Enc(x) yields the value C(x) but does not reveal anything else about x. Furthermore, no collusion of secret key holders should be able to learn anything more than the union of what they can each learn individually. We give constructions for indistinguishability obfuscation and functional encryption that supports all polynomial-size circuits. We accomplish this goal in three steps: (1) We describe a candidate construction for indistinguishability obfuscation for NC1 circuits. The security of this construction is based on a new algebraic hardness assumption. The candidate and assumption use a simplified variant of multilinear maps, which we call multilinear jigsaw puzzles. (2) We show how to use indistinguishability obfuscation for NC1 together with fully homomorphic encryption (with decryption in NC1) to achieve indistinguishability obfuscation for all circuits. (3) Finally, we show how to use indistinguishability obfuscation for circuits, public-key encryption, and noninteractive zero knowledge to achieve functional encryption for all circuits. The functional encryption scheme we construct also enjoys succinct ciphertexts, which enables several other applications.},
  file     = {:Garg2016 - Candidate Indistinguishability Obfuscation and Functional Encryption for All Circuits.PDF:PDF},
  groups   = {obfuscation},
  journal  = {SIAM Journal on Computing},
  keywords = {Functional encryption,Obfuscation,Predicate encryption},
  year     = {2016},
}

@InProceedings{Gosler1986,
  author    = {Gosler, James R},
  booktitle = {Advances in Cryptology --- CRYPTO '85 Proceedings},
  title     = {{Software Protection: Myth or Reality?}},
  editor    = {Williams, Hugh C},
  isbn      = {978-3-540-39799-1},
  pages     = {140--157},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {Staggering amounts of commercial software are marketed to fulfill needs from the PC explosion. Unfortunately, such software is trivial to duplicate! From the vendors' viewpoint a way to protect profit is needed. Typically, they have resorted to various schemes that attempt to inhibit the duplication process.},
  address   = {Berlin, Heidelberg},
  groups    = {obfuscation},
  year      = {1986},
}

@Article{Ollivier2019,
  author        = {Ollivier, Mathilde and Bardin, S{\'{e}}bastien and Bonichon, Richard and Marion, Jean-Yves},
  title         = {{How to kill symbolic deobfuscation for free (or: unleashing the potential of path-oriented protections)}},
  doi           = {10.1145/3359789.3359812},
  eprint        = {1908.01549},
  pages         = {177--189},
  abstract      = {Code obfuscation is a major tool for protecting software intellectual property from attacks such as reverse engineering or code tampering. Yet, recently proposed (automated) attacks based on Dynamic Symbolic Execution (DSE) shows very promising results, hence threatening software integrity. Current defenses are not fully satisfactory, being either not efficient against symbolic reasoning, or affecting runtime performance too much, or being too easy to spot. We present and study a new class of anti-DSE protections coined as path-oriented protections targeting the weakest spot of DSE, namely path exploration. We propose a lightweight, efficient, resistant and analytically proved class of obfuscation algorithms designed to hinder DSE-based attacks. Extensive evaluation demonstrates that these approaches critically counter symbolic deobfuscation while yielding only a very slight overhead.},
  archiveprefix = {arXiv},
  file          = {:Ollivier2019 - How to Kill Symbolic Deobfuscation for Free (or_ Unleashing the Potential of Path Oriented Protections).PDF:PDF},
  groups        = {obfuscation},
  year          = {2019},
}

@Article{Salwan2018,
  author   = {Salwan, Jonathan and Bardin, S{\'{e}}bastien and Potet, Marie Laure},
  title    = {{Symbolic deobfuscation: From virtualized code back to the original}},
  doi      = {10.1007/978-3-319-93411-2_17},
  issn     = {16113349},
  pages    = {372--392},
  volume   = {10885 LNCS},
  abstract = {Software protection has taken an important place during the last decade in order to protect legit software against reverse engineering or tampering. Virtualization is considered as one of the very best defenses against such attacks. We present a generic approach based on symbolic path exploration, taint and recompilation allowing to recover, from a virtualized code, a devirtualized code semantically identical to the original one and close in size. We define criteria and metrics to evaluate the relevance of the deobfuscated results in terms of correctness and precision. Finally we propose an open-source setup allowing to evaluate the proposed approach against several forms of virtualization.},
  file     = {:Salwan2018 - Symbolic Deobfuscation_ from Virtualized Code Back to the Original.PDF:PDF},
  groups   = {obfuscation},
  journal  = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
  year     = {2018},
}

@Article{Xu2017,
  author        = {Xu, Hui and Zhou, Yangfan and Kang, Yu and Lyu, Michael R.},
  date          = {2017-10-03},
  title         = {{On Secure and Usable Program Obfuscation: A Survey}},
  eprint        = {1710.01139},
  url           = {http://arxiv.org/abs/1710.01139},
  abstract      = {Program obfuscation is a widely employed approach for software intellectual property protection. However, general obfuscation methods (e.g., lexical obfuscation, control obfuscation) implemented in mainstream obfuscation tools are heuristic and have little security guarantee. Recently in 2013, Garg et al. have achieved a breakthrough in secure program obfuscation with a graded encoding mechanism and they have shown that it can fulfill a compelling security property, i.e., indistinguishability. Nevertheless, the mechanism incurs too much overhead for practical usage. Besides, it focuses on obfuscating computation models (e.g., circuits) rather than real codes. In this paper, we aim to explore secure and usable obfuscation approaches from the literature. Our main finding is that currently we still have no such approaches made secure and usable. The main reason is we do not have adequate evaluation metrics concerning both security and performance. On one hand, existing code-oriented obfuscation approaches generally evaluate the increased obscurity rather than security guarantee. On the other hand, the performance requirement for model-oriented obfuscation approaches is too weak to develop practical program obfuscation solutions.},
  archiveprefix = {arXiv},
  arxivid       = {1710.01139},
  file          = {:Xu2017 - On Secure and Usable Program Obfuscation_ a Survey.PDF:PDF},
  groups        = {obfuscation},
  journal       = {CoRR},
}

@Comment{jabref-meta: databaseType:biblatex;}

@Comment{jabref-meta: fileDirectory:./pdfs/;}

@Comment{jabref-meta: grouping:
0 AllEntriesGroup:;
1 StaticGroup:obfuscation\;0\;1\;0x8a8a8aff\;\;\;;
}

@Comment{jabref-meta: saveOrderConfig:specified;bibtexkey;false;author;false;title;true;}
